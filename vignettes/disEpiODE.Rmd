---
title: "disEpiODE"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{disEpiODE}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The disEpiODE package provides utility functions to create and discretise landscapes using square, hexagonal and triangular grids, and then apply a deterministic SI disease model to the grid.  The package is mostly intended to support the publication "Choice of Landscape Discretisation Method Affects the Inferred Rate of Spread in Wildlife Disease Spread Models" by Reimert et al (in review), but may also be useful for other work.

This vignette describes the basic steps required to re-create (and perhaps modify) the analyses presented in the publication.


## Package installation

The latest stable version of the package can be installed from our drat repository as follows:

```{r eval=FALSE}
install.packages("disEpiODE",
  repos=c("https://cran.rstudio.com/", "https://ku-awdc.github.io/drat/"))
```

Alternatively, the development version can be installed directly from GitHub using the remotes package:

```{r eval=FALSE}
install.packages("remotes")  # if necessary
remotes::install_github("https://github.com/ku-awdc/disEpiODE")
```

Both of these methods should also install the dependent packages, including deSolve (although the remotes package may need to . Binary versions of the package are not provided because the package does not contain compiled code, so should be installable from source on all platforms.

Once the package is installed, it can be loaded as usual.  We will also be using the sf and ggplot packages to visualise the process:

```{r}
library("disEpiODE")
library("sf")
library("ggplot2")
theme_set(theme_light())
```


## Creating a landscape

The first step is to create a landscape.  The spatial scale is arbitrary, so we use a unit square:

```{r}
landscape <- create_landscape(scale=1.0)
ggplot(landscape) + geom_sf()
```

We should then create the grid - either hexagonal, triangular or square - with given cell size based on the desired number of cells.  We can also specify a rotation angle (in degrees):

```{r}
grid_hex <- create_grid(landscape, cellarea = 0.01, celltype = "hexagon", rotate = 45)
ggplot() +
  geom_sf(data=landscape) +
  geom_sf(data=grid_hex)
```

This can be compared to e.g. a triangular grid with area of 0.002 and a rotation of 15 degrees:

```{r}
grid_tri <- create_grid(landscape, cellarea = 0.002, celltype = "triangle", rotate=15)
ggplot() +
  geom_sf(data=landscape) +
  geom_sf(data=grid_tri)
```

## Placing farms and setting initial infection

We then need to set the farms and their area of influence:

```{r}
farms <- create_farm_placement(landscape)
ggplot() +
  geom_sf(data=landscape) +
  geom_sf(aes(col=label), data=farms)
```

We can then calculate the intersection/overlap between grid patches and these farms, and then the initial state of the grid based on the intersection/overlap with the source patch:

```{r eval=FALSE}
## Mossa TODO
overlap <- create_farm_overlap(grid, farms)
init <- create_initial_state(grid, overlap, start_prev=0.5)
```


## Select a kernel and generate a transmission matrix


```{r eval=FALSE}
## Matt TODO
create_transmission_matrix(grid, inv_sigma, sigma=1)
## Note: kernel must be equal to 1 at distance = 0, i.e. diagonal ==1
```



## Running a disease model

```{r eval=FALSE}
## Mossa TODO
model <- create_si_model(grid, beta_mat, init, farms)

tau <- get_tau(model, prevalence=0.5)
get_trajectory(model, tmax=tau*1.5)
```



## Summarising results

```{r}
## Matt TODO (once model functions are in place)
```

