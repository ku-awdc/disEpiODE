---
title: "disEpiODE"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{disEpiODE}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The disEpiODE package provides utility functions to create and discretise landscapes using square, hexagonal and triangular grids, and then apply a deterministic SI disease model to the grid.  The package is mostly intended to support the publication "Choice of Landscape Discretisation Method Affects the Inferred Rate of Spread in Wildlife Disease Spread Models" by Reimert et al (in review), but may also be useful for other work.

This vignette describes the basic steps required to re-create (and perhaps modify) the analyses presented in the publication. The code required to install the package and access this vignette from within R is also available (in a format easier to copy/paste) from the GitHub repository at:  https://github.com/ku-awdc/disEpiODE


## Package installation

The latest stable version of the package can be installed from our drat repository as follows:

```{r eval=FALSE}
install.packages("disEpiODE",
  repos=c("https://cran.rstudio.com/", "https://ku-awdc.github.io/drat/"))
```

Alternatively, the development version can be installed directly from GitHub using the remotes package:

```{r eval=FALSE}
install.packages("remotes")  # if necessary
remotes::install_github("https://github.com/ku-awdc/disEpiODE")
```

Both of these methods should also install the dependent packages, including deSolve (although the remotes package may need to . Binary versions of the package are not provided because the package does not contain compiled code, so should be installable from source on all platforms.

Once the package is installed, it can be loaded as usual and this vignette can be accessed directly:

```{r}
library("disEpiODE")
# vignette("disEpiODE", package="disEpiODE")
```


We will also be using the sf and ggplot packages within this vignette:

```{r}
library("sf")
library("ggplot2")
theme_set(theme_light())
```


## Creating a landscape

The first step is to create a landscape.  The spatial scale is arbitrary, so we use a unit square:

```{r}
landscape <- create_landscape(scale=1.0)
ggplot(landscape) + geom_sf()
```

We should then create the grid - either hexagonal, triangular or square - with given cell size based on the desired number of cells.  We can also specify a rotation angle (in degrees):

```{r}
grid <- create_grid(landscape, cellarea = 0.01, celltype = "hexagon", rotate = 45)
ggplot() +
  geom_sf(data=landscape) +
  geom_sf(data=grid)
```

This can be compared to e.g. a simple square grid:

```{r}
grid_sq <- create_grid(landscape, cellarea = 0.01, celltype = "square")
ggplot() +
  geom_sf(data=landscape) +
  geom_sf(data=grid_sq)
```

Or a more complex triangular grid with area of 0.002 and a rotation of 15 degrees:

```{r}
grid_tri <- create_grid(landscape, cellarea = 0.002, celltype = "triangle", rotate=15)
ggplot() +
  geom_sf(data=landscape) +
  geom_sf(data=grid_tri)
```




Note that the number of patches can be inspected from the number of rows in the grid. This may be more than implied by the input area due to the presence of partial patches intersecting the bounday of the landscape:

```{r}
nrow(grid); 1/0.01
nrow(grid_sq); 1/0.01
nrow(grid_tri); 1/0.002
```


## Placing farms and setting initial infection

We then need to set the farms and their area of influence:

```{r}
farms <- create_farm_placement(landscape)
ggplot() +
  geom_sf(data=landscape) +
  geom_sf(aes(col=label), data=farms)
```

We can then calculate the intersection/overlap between grid patches and these farms, and then the initial state of the grid based on the intersection/overlap with the source patch:

```{r eval=FALSE}
## Mossa TODO
overlap <- create_farm_overlap(grid, farms)
init <- create_initial_state(grid, overlap, start_prev=0.5)
```


## Select a kernel and generate a transmission matrix

We also need to define a transmission kernel. This can be any user-specified function that takes a numeric (non-negative) vector of inputs and returns a numeric (non-negative) vector of equal length, with the additional constraint that input values of zero must map to an output of one, representing within-patch transmission. Output for strictly positive inputs can therefore be interpreted as being relative to within-patch transmission. It would be usual for the kernel to be monotonically decreasing, but this is not strictly necessary for the code.

A helper function to generate an inverse/half-normal/expontential kernel with arbitrary sigma value is provided by the package:

```{r}
kernel <- create_kernel("inverse", sigma=100)
kernel(seq(0,0.5,by=0.1))
```

Once the grid and kernel are available, a transmission matrix can be generated with the desired within-patch transmission rate (beta_baseline). This will always be a symmetric matrix with dimension equal to the number of patches, and a diagnonal equal to beta_baseline.

```{r}
beta_matrix <- create_transmission_matrix(grid, kernel, beta_baseline=0.05)
nrow(grid)
dim(beta_matrix)
beta_matrix[1:5,1:5]
```


## Running a disease model

```{r eval=FALSE}
## Mossa TODO
model <- create_si_model(grid, beta_matrix, init, farms)

tau <- get_tau(model, prevalence=0.5)
get_trajectory(model, tmax=tau*1.5)
```



## Summarising results

```{r}
## Matt TODO (once model functions are in place)
```

