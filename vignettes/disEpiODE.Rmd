---
title: "disEpiODE"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{disEpiODE}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The disEpiODE package provides utility functions to create and discretise landscapes using square, hexagonal and triangular grids, and then apply a deterministic SI disease model to the grid.  The package is mostly intended to support the publication "Choice of Landscape Discretisation Method Affects the Inferred Rate of Spread in Wildlife Disease Spread Models" by Reimert et al (in review), but may also be useful for other work.

This vignette describes the basic steps required to re-create (and perhaps modify) the analyses presented in the publication.


## Package installation

The latest stable version of the package can be installed from our drat repository as follows:

```{r eval=FALSE}
install.packages("disEpiODE", repos=c("https://cran.rstudio.com/", "https://ku-awdc.github.io/drat/"))
```

Alternatively, the development version can be installed directly from GitHub using the remotes package:

```{r eval=FALSE}
install.packages("remotes")  # if necessary
remotes::install_github("https://github.com/ku-awdc/disEpiODE")
```

Both of these methods should also install the dependent packages, including deSolve (although the remotes package may need to . Binary versions of the package are not provided because the package does not contain compiled code, so should be installable from source on all platforms.

Once the package is installed, it can be loaded as usual.  We will also be using the sf and ggplot packages to visualise the process:

```{r}
library("disEpiODE")
library("sf")
library("ggplot2")
theme_set(theme_light())
```


## Creating a landscape

The first step is to create a landscape.  The spatial scale is arbitrary, so we use a unit square:

```{r}
area <- 1.0
landscape <- create_landscape(area)
ggplot(landscape$landscape) + geom_sf()
```

We should then create the grid - either hexagonal, triangular or square - with given cell size based on the desired number of cells.

```{r}
## TODO: argument to rotate grid in degrees

grid_hex <- create_grid(landscape, cellarea = 0.01, celltype = "hexagon")
ggplot() +
  geom_sf(data=landscape) +
  geom_sf(data=grid_hex)
```

This can be compared to e.g. a triangular grid with 500 cells:

```{r}
n_cells <- 500

grid_tri <- create_grid(landscape, cellarea = area/n_cells, celltype = "triangle")
ggplot() +
  geom_sf(data=landscape) +
  geom_sf(data=grid_tri)
```

## Placing farms and setting initial infection



We then need to add the farms and their area of influence.  

```{r}
farms <- create_farm_placement(angle = 45)
```


```{r}
overlap <- create_farm_overlap(grid, farms)
```

```{r}
init <- create_initial_state(grid, overlap)
```


## Selecting a kernel and generate a transmission matrix


```{r}
create_transmission_matrix(grid, inv_sigma, sigma=1)
## Note: kernel must be equal to 1 at distance = 0, i.e. diagonal ==1
```



## Running a disease model

```{r}
model <- create_si_model(grid, beta_mat, init, farms)

tau <- get_tau(model, prevalence=0.5)
get_trajectory(model, tmax=tau*1.5)
```



## Summarising results

